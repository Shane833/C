BubbleDown	PQueue.c	/^static void BubbleDown(PQueue* q, int element_index)$/;"	f	typeref:typename:void	file:
BubbleUp	PQueue.c	/^static void BubbleUp(PQueue* q, int element_index)$/;"	f	typeref:typename:void	file:
LeftChild	PQueue.c	/^static int LeftChild(PQueue* q, int parent_index)$/;"	f	typeref:typename:int	file:
PQ_Swap	PQueue.c	/^static void PQ_Swap(PQueue* q, const int a_index, const int b_index)$/;"	f	typeref:typename:void	file:
PQueue_ClearDestroy	PQueue.c	/^void  PQueue_ClearDestroy(PQueue* q)$/;"	f	typeref:typename:void
PQueue_Create	PQueue.c	/^PQueue* PQueue_Create(size_t size, PQueue_Compare cmp)$/;"	f	typeref:typename:PQueue *
PQueue_CreateFromArray	PQueue.c	/^PQueue* PQueue_CreateFromArray(void** array, size_t size, PQueue_Compare cmp)$/;"	f	typeref:typename:PQueue *
PQueue_CreateFromStaticArray	PQueue.c	/^PQueue* PQueue_CreateFromStaticArray(void** array, size_t size, PQueue_Compare cmp)$/;"	f	typeref:typename:PQueue *
PQueue_Dequeue	PQueue.c	/^void* PQueue_Dequeue(PQueue* q)$/;"	f	typeref:typename:void *
PQueue_Destroy	PQueue.c	/^void PQueue_Destroy(PQueue* q)$/;"	f	typeref:typename:void
PQueue_Enqueue	PQueue.c	/^void PQueue_Enqueue(PQueue* q, void* element)$/;"	f	typeref:typename:void
Parent	PQueue.c	/^static int Parent(PQueue* q, int child_index)$/;"	f	typeref:typename:int	file:
RightChild	PQueue.c	/^static int RightChild(PQueue* q, int parent_index)$/;"	f	typeref:typename:int	file:
PQueue	PQueue.h	/^typedef struct PQueue{$/;"	s
PQueue	PQueue.h	/^}PQueue;$/;"	t	typeref:struct:PQueue
PQueue_Compare	PQueue.h	/^typedef int (*PQueue_Compare) (const void*, const void* b);$/;"	t	typeref:typename:int (*)(const void *,const void * b)
PQueue_Free	PQueue.h	/^#define PQueue_Free(/;"	d
PQueue_Get	PQueue.h	/^static inline void* PQueue_Get(PQueue* q, int index)$/;"	f	typeref:typename:void *
PQueue_Size	PQueue.h	/^#define PQueue_Size(/;"	d
__PQUEUE_H__	PQueue.h	/^#define __PQUEUE_H__$/;"	d
array	PQueue.h	/^	void** array;$/;"	m	struct:PQueue	typeref:typename:void **
cmp	PQueue.h	/^	PQueue_Compare cmp;$/;"	m	struct:PQueue	typeref:typename:PQueue_Compare
end	PQueue.h	/^	int end;$/;"	m	struct:PQueue	typeref:typename:int
max	PQueue.h	/^	size_t max;$/;"	m	struct:PQueue	typeref:typename:size_t
BSSSC_BUFF_LEN	bstrlib.c	/^#define BSSSC_BUFF_LEN /;"	d	file:
BSTRLIB_NOVSNP	bstrlib.c	/^#  define BSTRLIB_NOVSNP$/;"	d	file:
BS_BUFF_SZ	bstrlib.c	/^#define BS_BUFF_SZ /;"	d	file:
CFCLEN	bstrlib.c	/^#define CFCLEN /;"	d	file:
INITIAL_STATIC_FIND_INDEX_COUNT	bstrlib.c	/^#define INITIAL_STATIC_FIND_INDEX_COUNT /;"	d	file:
LONG_BITS_QTY	bstrlib.c	/^#define LONG_BITS_QTY /;"	d	file:
LONG_LOG_BITS_QTY	bstrlib.c	/^#define LONG_LOG_BITS_QTY /;"	d	file:
LONG_TYPE	bstrlib.c	/^#define LONG_TYPE /;"	d	file:
START_VSNBUFF	bstrlib.c	/^#define START_VSNBUFF /;"	d	file:
_CRT_SECURE_NO_WARNINGS	bstrlib.c	/^# define _CRT_SECURE_NO_WARNINGS$/;"	d	file:
b	bstrlib.c	/^	bstring b;$/;"	m	struct:genBstrList	typeref:typename:bstring	file:
bBlockCopy	bstrlib.c	/^#define bBlockCopy(/;"	d	file:
bStream	bstrlib.c	/^struct bStream {$/;"	s	file:
balloc	bstrlib.c	/^int balloc (bstring b, int olen) {$/;"	f	typeref:typename:int
ballocmin	bstrlib.c	/^int ballocmin (bstring b, int len) {$/;"	f	typeref:typename:int
bassign	bstrlib.c	/^int bassign (bstring a, const_bstring b) {$/;"	f	typeref:typename:int
bassignblk	bstrlib.c	/^int bassignblk (bstring a, const void * s, int len) {$/;"	f	typeref:typename:int
bassigncstr	bstrlib.c	/^int bassigncstr (bstring a, const char * str) {$/;"	f	typeref:typename:int
bassignformat	bstrlib.c	/^int bassignformat (bstring b, const char * fmt, ...) {$/;"	f	typeref:typename:int
bassigngets	bstrlib.c	/^int bassigngets (bstring b, bNgetc getcPtr, void * parm, char terminator) {$/;"	f	typeref:typename:int
bassignmidstr	bstrlib.c	/^int bassignmidstr (bstring a, const_bstring b, int left, int len) {$/;"	f	typeref:typename:int
bcatblk	bstrlib.c	/^int bcatblk (bstring b, const void * s, int len) {$/;"	f	typeref:typename:int
bcatcstr	bstrlib.c	/^int bcatcstr (bstring b, const char * s) {$/;"	f	typeref:typename:int
bconcat	bstrlib.c	/^int bconcat (bstring b0, const_bstring b1) {$/;"	f	typeref:typename:int
bconchar	bstrlib.c	/^int bconchar (bstring b, char c) {$/;"	f	typeref:typename:int
bcstrfree	bstrlib.c	/^int bcstrfree (char * s) {$/;"	f	typeref:typename:int
bdelete	bstrlib.c	/^int bdelete (bstring b, int pos, int len) {$/;"	f	typeref:typename:int
bdestroy	bstrlib.c	/^int bdestroy (bstring b) {$/;"	f	typeref:typename:int
bfindreplace	bstrlib.c	/^int bfindreplace (bstring b, const_bstring find, const_bstring repl,$/;"	f	typeref:typename:int
bfindreplacecaseless	bstrlib.c	/^int bfindreplacecaseless (bstring b, const_bstring find, const_bstring repl,$/;"	f	typeref:typename:int
bformat	bstrlib.c	/^bstring bformat (const char * fmt, ...) {$/;"	f	typeref:typename:bstring
bformata	bstrlib.c	/^int bformata (bstring b, const char * fmt, ...) {$/;"	f	typeref:typename:int
bfromcstr	bstrlib.c	/^bstring bfromcstr (const char * str) {$/;"	f	typeref:typename:bstring
bfromcstralloc	bstrlib.c	/^bstring bfromcstralloc (int mlen, const char * str) {$/;"	f	typeref:typename:bstring
bfromcstrrangealloc	bstrlib.c	/^bstring bfromcstrrangealloc (int minl, int maxl, const char* str) {$/;"	f	typeref:typename:bstring
bgets	bstrlib.c	/^bstring bgets (bNgetc getcPtr, void * parm, char terminator) {$/;"	f	typeref:typename:bstring
bgetsa	bstrlib.c	/^int bgetsa (bstring b, bNgetc getcPtr, void * parm, char terminator) {$/;"	f	typeref:typename:int
binchr	bstrlib.c	/^int binchr (const_bstring b0, int pos, const_bstring b1) {$/;"	f	typeref:typename:int
binchrCF	bstrlib.c	/^static int binchrCF (const unsigned char * data, int len, int pos,$/;"	f	typeref:typename:int	file:
binchrr	bstrlib.c	/^int binchrr (const_bstring b0, int pos, const_bstring b1) {$/;"	f	typeref:typename:int
binchrrCF	bstrlib.c	/^static int binchrrCF (const unsigned char * data, int pos,$/;"	f	typeref:typename:int	file:
binsert	bstrlib.c	/^int binsert (bstring b1, int pos, const_bstring b2, unsigned char fill) {$/;"	f	typeref:typename:int
binsertblk	bstrlib.c	/^int binsertblk (bstring b, int pos, const void * blk, int len,$/;"	f	typeref:typename:int
binsertch	bstrlib.c	/^int binsertch (bstring b, int pos, int len, unsigned char fill) {$/;"	f	typeref:typename:int
binstr	bstrlib.c	/^int binstr (const_bstring b1, int pos, const_bstring b2) {$/;"	f	typeref:typename:int
binstrcaseless	bstrlib.c	/^int binstrcaseless (const_bstring b1, int pos, const_bstring b2) {$/;"	f	typeref:typename:int
binstrr	bstrlib.c	/^int binstrr (const_bstring b1, int pos, const_bstring b2) {$/;"	f	typeref:typename:int
binstrrcaseless	bstrlib.c	/^int binstrrcaseless (const_bstring b1, int pos, const_bstring b2) {$/;"	f	typeref:typename:int
biseq	bstrlib.c	/^int biseq (const_bstring b0, const_bstring b1) {$/;"	f	typeref:typename:int
biseqblk	bstrlib.c	/^int biseqblk (const_bstring b, const void * blk, int len) {$/;"	f	typeref:typename:int
biseqcaseless	bstrlib.c	/^int biseqcaseless (const_bstring b0, const_bstring b1) {$/;"	f	typeref:typename:int
biseqcaselessblk	bstrlib.c	/^int biseqcaselessblk (const_bstring b, const void * blk, int len) {$/;"	f	typeref:typename:int
biseqcstr	bstrlib.c	/^int biseqcstr (const_bstring b, const char * s) {$/;"	f	typeref:typename:int
biseqcstrcaseless	bstrlib.c	/^int biseqcstrcaseless (const_bstring b, const char * s) {$/;"	f	typeref:typename:int
bisstemeqblk	bstrlib.c	/^int bisstemeqblk (const_bstring b0, const void * blk, int len) {$/;"	f	typeref:typename:int
bisstemeqcaselessblk	bstrlib.c	/^int bisstemeqcaselessblk (const_bstring b0, const void * blk, int len) {$/;"	f	typeref:typename:int
bjoin	bstrlib.c	/^bstring bjoin (const struct bstrList * bl, const_bstring sep) {$/;"	f	typeref:typename:bstring
bjoinblk	bstrlib.c	/^bstring bjoinblk (const struct bstrList * bl, const void * blk, int len) {$/;"	f	typeref:typename:bstring
bl	bstrlib.c	/^	struct bstrList * bl;$/;"	m	struct:genBstrList	typeref:struct:bstrList *	file:
blk2bstr	bstrlib.c	/^bstring blk2bstr (const void * blk, int len) {$/;"	f	typeref:typename:bstring
bltrimws	bstrlib.c	/^int bltrimws (bstring b) {$/;"	f	typeref:typename:int
bmidstr	bstrlib.c	/^bstring bmidstr (const_bstring b, int left, int len) {$/;"	f	typeref:typename:bstring
bninchr	bstrlib.c	/^int bninchr (const_bstring b0, int pos, const_bstring b1) {$/;"	f	typeref:typename:int
bninchrr	bstrlib.c	/^int bninchrr (const_bstring b0, int pos, const_bstring b1) {$/;"	f	typeref:typename:int
bpattern	bstrlib.c	/^int bpattern (bstring b, int len) {$/;"	f	typeref:typename:int
bread	bstrlib.c	/^bstring bread (bNread readPtr, void * parm) {$/;"	f	typeref:typename:bstring
breada	bstrlib.c	/^int breada (bstring b, bNread readPtr, void * parm) {$/;"	f	typeref:typename:int
breplace	bstrlib.c	/^int breplace (bstring b1, int pos, int len, const_bstring b2,$/;"	f	typeref:typename:int
brtrimws	bstrlib.c	/^int brtrimws (bstring b) {$/;"	f	typeref:typename:int
bsbufflength	bstrlib.c	/^int bsbufflength (struct bStream * s, int sz) {$/;"	f	typeref:typename:int
bscb	bstrlib.c	/^static int bscb (void * parm, int ofs, int len) {$/;"	f	typeref:typename:int	file:
bsclose	bstrlib.c	/^void * bsclose (struct bStream * s) {$/;"	f	typeref:typename:void *
bseof	bstrlib.c	/^int bseof (const struct bStream * s) {$/;"	f	typeref:typename:int
bsetstr	bstrlib.c	/^int bsetstr (bstring b0, int pos, const_bstring b1, unsigned char fill) {$/;"	f	typeref:typename:int
bsopen	bstrlib.c	/^struct bStream * bsopen (bNread readPtr, void * parm) {$/;"	f	typeref:struct:bStream *
bspeek	bstrlib.c	/^int bspeek (bstring r, const struct bStream * s) {$/;"	f	typeref:typename:int
bsplit	bstrlib.c	/^struct bstrList * bsplit (const_bstring str, unsigned char splitChar) {$/;"	f	typeref:struct:bstrList *
bsplitcb	bstrlib.c	/^int bsplitcb (const_bstring str, unsigned char splitChar, int pos,$/;"	f	typeref:typename:int
bsplits	bstrlib.c	/^struct bstrList * bsplits (const_bstring str, const_bstring splitStr) {$/;"	f	typeref:struct:bstrList *
bsplitscb	bstrlib.c	/^int bsplitscb (const_bstring str, const_bstring splitStr, int pos,$/;"	f	typeref:typename:int
bsplitstr	bstrlib.c	/^struct bstrList * bsplitstr (const_bstring str, const_bstring splitStr) {$/;"	f	typeref:struct:bstrList *
bsplitstrcb	bstrlib.c	/^int bsplitstrcb (const_bstring str, const_bstring splitStr, int pos,$/;"	f	typeref:typename:int
bsread	bstrlib.c	/^int bsread (bstring r, struct bStream * s, int n) {$/;"	f	typeref:typename:int
bsreada	bstrlib.c	/^int bsreada (bstring r, struct bStream * s, int n) {$/;"	f	typeref:typename:int
bsreadln	bstrlib.c	/^int bsreadln (bstring r, struct bStream * s, char terminator) {$/;"	f	typeref:typename:int
bsreadlna	bstrlib.c	/^int bsreadlna (bstring r, struct bStream * s, char terminator) {$/;"	f	typeref:typename:int
bsreadlns	bstrlib.c	/^int bsreadlns (bstring r, struct bStream * s, const_bstring term) {$/;"	f	typeref:typename:int
bsreadlnsa	bstrlib.c	/^int bsreadlnsa (bstring r, struct bStream * s, const_bstring term) {$/;"	f	typeref:typename:int
bssplitscb	bstrlib.c	/^int bssplitscb (struct bStream * s, const_bstring splitStr,$/;"	f	typeref:typename:int
bssplitstrcb	bstrlib.c	/^int bssplitstrcb (struct bStream * s, const_bstring splitStr,$/;"	f	typeref:typename:int
bstr2cstr	bstrlib.c	/^char * bstr2cstr (const_bstring b, char z) {$/;"	f	typeref:typename:char *
bstrListAlloc	bstrlib.c	/^int bstrListAlloc (struct bstrList * sl, int msz) {$/;"	f	typeref:typename:int
bstrListAllocMin	bstrlib.c	/^int bstrListAllocMin (struct bstrList * sl, int msz) {$/;"	f	typeref:typename:int
bstrListCreate	bstrlib.c	/^struct bstrList * bstrListCreate (void) {$/;"	f	typeref:struct:bstrList *
bstrListDestroy	bstrlib.c	/^int bstrListDestroy (struct bstrList * sl) {$/;"	f	typeref:typename:int
bstr__alloc	bstrlib.c	/^#define bstr__alloc(/;"	d	file:
bstr__alloc	bstrlib.c	/^void* bstr__alloc (size_t sz) {$/;"	f	typeref:typename:void *
bstr__free	bstrlib.c	/^#define bstr__free(/;"	d	file:
bstr__memchr	bstrlib.c	/^#define bstr__memchr(/;"	d	file:
bstr__memcmp	bstrlib.c	/^#define bstr__memcmp(/;"	d	file:
bstr__memcpy	bstrlib.c	/^#define bstr__memcpy(/;"	d	file:
bstr__memmove	bstrlib.c	/^#define bstr__memmove(/;"	d	file:
bstr__memset	bstrlib.c	/^#define bstr__memset(/;"	d	file:
bstr__realloc	bstrlib.c	/^#define bstr__realloc(/;"	d	file:
bstrchrp	bstrlib.c	/^int bstrchrp (const_bstring b, int c, int pos) {$/;"	f	typeref:typename:int
bstrcmp	bstrlib.c	/^int bstrcmp (const_bstring b0, const_bstring b1) {$/;"	f	typeref:typename:int
bstrcpy	bstrlib.c	/^bstring bstrcpy (const_bstring b) {$/;"	f	typeref:typename:bstring
bstricmp	bstrlib.c	/^int bstricmp (const_bstring b0, const_bstring b1) {$/;"	f	typeref:typename:int
bstrncmp	bstrlib.c	/^int bstrncmp (const_bstring b0, const_bstring b1, int n) {$/;"	f	typeref:typename:int
bstrnicmp	bstrlib.c	/^int bstrnicmp (const_bstring b0, const_bstring b1, int n) {$/;"	f	typeref:typename:int
bstrrchrp	bstrlib.c	/^int bstrrchrp (const_bstring b, int c, int pos) {$/;"	f	typeref:typename:int
bsunread	bstrlib.c	/^int bsunread (struct bStream * s, const_bstring b) {$/;"	f	typeref:typename:int
btolower	bstrlib.c	/^int btolower (bstring b) {$/;"	f	typeref:typename:int
btoupper	bstrlib.c	/^int btoupper (bstring b) {$/;"	f	typeref:typename:int
btrimws	bstrlib.c	/^int btrimws (bstring b) {$/;"	f	typeref:typename:int
btrunc	bstrlib.c	/^int btrunc (bstring b, int n) {$/;"	f	typeref:typename:int
buff	bstrlib.c	/^	bstring buff;		\/* Buffer for over-reads *\/$/;"	m	struct:bStream	typeref:typename:bstring	file:
buildCharField	bstrlib.c	/^static int buildCharField (struct charField * cf, const_bstring b) {$/;"	f	typeref:typename:int	file:
bvcformata	bstrlib.c	/^int bvcformata (bstring b, int count, const char * fmt, va_list arg) {$/;"	f	typeref:typename:int
charField	bstrlib.c	/^struct charField { LONG_TYPE content[CFCLEN]; };$/;"	s	file:
charField	bstrlib.c	/^struct charField { unsigned char content[CFCLEN]; };$/;"	s	file:
content	bstrlib.c	/^struct charField { LONG_TYPE content[CFCLEN]; };$/;"	m	struct:charField	typeref:typename:LONG_TYPE[]	file:
content	bstrlib.c	/^struct charField { unsigned char content[CFCLEN]; };$/;"	m	struct:charField	typeref:typename:unsigned char[]	file:
downcase	bstrlib.c	/^#define downcase(/;"	d	file:
exvsnprintf	bstrlib.c	/^#define exvsnprintf(/;"	d	file:
findreplaceengine	bstrlib.c	/^static int findreplaceengine (bstring b, const_bstring find,$/;"	f	typeref:typename:int	file:
genBstrList	bstrlib.c	/^struct genBstrList {$/;"	s	file:
instr_fnptr	bstrlib.c	/^typedef int (*instr_fnptr) (const_bstring s1, int pos, const_bstring s2);$/;"	t	typeref:typename:int (*)(const_bstring s1,int pos,const_bstring s2)	file:
invertCharField	bstrlib.c	/^static void invertCharField (struct charField * cf) {$/;"	f	typeref:typename:void	file:
isEOF	bstrlib.c	/^	int isEOF;			\/* track file's EOF state *\/$/;"	m	struct:bStream	typeref:typename:int	file:
maxBuffSz	bstrlib.c	/^	int maxBuffSz;$/;"	m	struct:bStream	typeref:typename:int	file:
parm	bstrlib.c	/^	void * parm;		\/* The stream handle for core stream *\/$/;"	m	struct:bStream	typeref:typename:void *	file:
readFnPtr	bstrlib.c	/^	bNread readFnPtr;	\/* fread compatible fnptr for core stream *\/$/;"	m	struct:bStream	typeref:typename:bNread	file:
setInCharField	bstrlib.c	/^#define setInCharField(/;"	d	file:
snapUpSize	bstrlib.c	/^static int snapUpSize (int i) {$/;"	f	typeref:typename:int	file:
testInCharField	bstrlib.c	/^#define testInCharField(/;"	d	file:
upcase	bstrlib.c	/^#define   upcase(/;"	d	file:
wspace	bstrlib.c	/^#define   wspace(/;"	d	file:
BSTRLIB_INCLUDE	bstrlib.h	/^#define BSTRLIB_INCLUDE$/;"	d
BSTRLIB_NOVSNP	bstrlib.h	/^#  define BSTRLIB_NOVSNP$/;"	d
BSTR_BS_BUFF_LENGTH_GET	bstrlib.h	/^#define BSTR_BS_BUFF_LENGTH_GET /;"	d
BSTR_ERR	bstrlib.h	/^#define BSTR_ERR /;"	d
BSTR_OK	bstrlib.h	/^#define BSTR_OK /;"	d
BSTR_VER_MAJOR	bstrlib.h	/^#define BSTR_VER_MAJOR /;"	d
BSTR_VER_MINOR	bstrlib.h	/^#define BSTR_VER_MINOR /;"	d
BSTR_VER_UPDATE	bstrlib.h	/^#define BSTR_VER_UPDATE /;"	d
bNgetc	bstrlib.h	/^typedef int (*bNgetc) (void *parm);$/;"	t	typeref:typename:int (*)(void * parm)
bNread	bstrlib.h	/^typedef size_t (* bNread) (void *buff, size_t elsize, size_t nelem, void *parm);$/;"	t	typeref:typename:size_t (*)(void * buff,size_t elsize,size_t nelem,void * parm)
bassignStatic	bstrlib.h	/^#define bassignStatic(/;"	d
bcatStatic	bstrlib.h	/^#define bcatStatic(/;"	d
bchar	bstrlib.h	/^#define bchar(/;"	d
bchare	bstrlib.h	/^#define bchare(/;"	d
bdata	bstrlib.h	/^#define bdata(/;"	d
bdatae	bstrlib.h	/^#define bdatae(/;"	d
bdataofs	bstrlib.h	/^#define bdataofs(/;"	d
bdataofse	bstrlib.h	/^#define bdataofse(/;"	d
bfromStatic	bstrlib.h	/^#define bfromStatic(/;"	d
binsertStatic	bstrlib.h	/^#define binsertStatic(/;"	d
biseqStatic	bstrlib.h	/^#define biseqStatic(/;"	d
biseqcaselessStatic	bstrlib.h	/^#define biseqcaselessStatic(/;"	d
bisstemeqStatic	bstrlib.h	/^#define bisstemeqStatic(/;"	d
bisstemeqcaselessStatic	bstrlib.h	/^#define bisstemeqcaselessStatic(/;"	d
biswriteprotected	bstrlib.h	/^#define biswriteprotected(/;"	d
bjoinStatic	bstrlib.h	/^#define bjoinStatic(/;"	d
blength	bstrlib.h	/^#define blength(/;"	d
blengthe	bstrlib.h	/^#define blengthe(/;"	d
blk2tbstr	bstrlib.h	/^#define blk2tbstr(/;"	d
bmid2tbstr	bstrlib.h	/^#define bmid2tbstr(/;"	d
bsStatic	bstrlib.h	/^# define bsStatic(/;"	d
bsStaticBlkParms	bstrlib.h	/^#define bsStaticBlkParms(/;"	d
bsStaticMlen	bstrlib.h	/^#define bsStaticMlen(/;"	d
bstrList	bstrlib.h	/^struct bstrList {$/;"	s
bstrchr	bstrlib.h	/^#define bstrchr(/;"	d
bstring	bstrlib.h	/^typedef struct tagbstring * bstring;$/;"	t	typeref:struct:tagbstring *
bstrrchr	bstrlib.h	/^#define bstrrchr(/;"	d
btfromblk	bstrlib.h	/^#define btfromblk(/;"	d
btfromblkltrimws	bstrlib.h	/^#define btfromblkltrimws(/;"	d
btfromblkrtrimws	bstrlib.h	/^#define btfromblkrtrimws(/;"	d
btfromblktrimws	bstrlib.h	/^#define btfromblktrimws(/;"	d
btfromcstr	bstrlib.h	/^#define btfromcstr(/;"	d
bvformata	bstrlib.h	/^#define bvformata(/;"	d
bwriteallow	bstrlib.h	/^#define bwriteallow(/;"	d
bwriteprotect	bstrlib.h	/^#define bwriteprotect(/;"	d
const_bstring	bstrlib.h	/^typedef const struct tagbstring * const_bstring;$/;"	t	typeref:typename:const struct tagbstring *
cstr2bstr	bstrlib.h	/^#define cstr2bstr /;"	d
cstr2tbstr	bstrlib.h	/^#define cstr2tbstr /;"	d
data	bstrlib.h	/^	unsigned char * data;$/;"	m	struct:tagbstring	typeref:typename:unsigned char *
entry	bstrlib.h	/^    bstring * entry;$/;"	m	struct:bstrList	typeref:typename:bstring *
mlen	bstrlib.h	/^	int mlen;$/;"	m	struct:tagbstring	typeref:typename:int
mlen	bstrlib.h	/^    int qty, mlen;$/;"	m	struct:bstrList	typeref:typename:int
qty	bstrlib.h	/^    int qty, mlen;$/;"	m	struct:bstrList	typeref:typename:int
slen	bstrlib.h	/^	int slen;$/;"	m	struct:tagbstring	typeref:typename:int
tagbstring	bstrlib.h	/^struct tagbstring {$/;"	s
DArray_clear	darray.c	/^void DArray_clear(DArray* array)$/;"	f	typeref:typename:void
DArray_clear_destroy	darray.c	/^void DArray_clear_destroy(DArray* array)$/;"	f	typeref:typename:void
DArray_contract	darray.c	/^int DArray_contract(DArray* array)$/;"	f	typeref:typename:int
DArray_create	darray.c	/^DArray* DArray_create(size_t element_size, size_t initial_max)$/;"	f	typeref:typename:DArray *
DArray_destroy	darray.c	/^void DArray_destroy(DArray* array)$/;"	f	typeref:typename:void
DArray_expand	darray.c	/^int DArray_expand(DArray* array)$/;"	f	typeref:typename:int
DArray_pop	darray.c	/^void* DArray_pop(DArray* array)$/;"	f	typeref:typename:void *
DArray_push	darray.c	/^int DArray_push(DArray* array, void* el)$/;"	f	typeref:typename:int
DArray_resize	darray.c	/^static inline int DArray_resize(DArray* array, size_t newsize)$/;"	f	typeref:typename:int	file:
DArray	darray.h	/^typedef struct DArray{$/;"	s
DArray	darray.h	/^}DArray;$/;"	t	typeref:struct:DArray
DArray_count	darray.h	/^#define DArray_count(/;"	d
DArray_end	darray.h	/^#define DArray_end(/;"	d
DArray_first	darray.h	/^#define DArray_first(/;"	d
DArray_free	darray.h	/^#define DArray_free(/;"	d
DArray_get	darray.h	/^static inline void* DArray_get(DArray* array, int i)$/;"	f	typeref:typename:void *
DArray_last	darray.h	/^#define DArray_last(/;"	d
DArray_max	darray.h	/^#define DArray_max(/;"	d
DArray_new	darray.h	/^static inline void* DArray_new(DArray* array)$/;"	f	typeref:typename:void *
DArray_remove	darray.h	/^static inline void* DArray_remove(DArray* array, int i)$/;"	f	typeref:typename:void *
DArray_set	darray.h	/^static inline void DArray_set(DArray* array, int i, void* el)$/;"	f	typeref:typename:void
DEFAULT_EXPAND_RATE	darray.h	/^#define DEFAULT_EXPAND_RATE /;"	d
_DArray_h	darray.h	/^#define _DArray_h$/;"	d
contents	darray.h	/^	void** contents; \/\/ the data of the array itself will be stored here$/;"	m	struct:DArray	typeref:typename:void **
element_size	darray.h	/^	size_t element_size; \/\/ fixed size of each element that it needs to store$/;"	m	struct:DArray	typeref:typename:size_t
end	darray.h	/^	int end; \/\/ maintains the end pointer, the point where insertion takes place$/;"	m	struct:DArray	typeref:typename:int
expand_rate	darray.h	/^	size_t expand_rate; \/\/ defines how much ammount you want to grow the array after its initial /;"	m	struct:DArray	typeref:typename:size_t
max	darray.h	/^	int max; \/\/ holds the maximum array size and then flags to grow it once the limit is reached$/;"	m	struct:DArray	typeref:typename:int
DArray_find	darray_algos.c	/^int DArray_find(DArray* array, void* el, DArray_compare cmp)$/;"	f	typeref:typename:int
DArray_heapsort	darray_algos.c	/^int DArray_heapsort(DArray* array, DArray_compare cmp)$/;"	f	typeref:typename:int
DArray_mergesort	darray_algos.c	/^int DArray_mergesort(DArray* array, DArray_compare cmp)$/;"	f	typeref:typename:int
DArray_quicksort	darray_algos.c	/^int DArray_quicksort(DArray* array, DArray_compare cmp)$/;"	f	typeref:typename:int
DArray_sort_add	darray_algos.c	/^int DArray_sort_add(DArray* array, void* el, DArray_compare cmp, int DArray_sort_algo)$/;"	f	typeref:typename:int
divide	darray_algos.c	/^static void divide(DArray* array, int low, int high, DArray_compare cmp) \/\/ helper function$/;"	f	typeref:typename:void	file:
merge	darray_algos.c	/^static void merge(DArray* array, int low, int mid, int high, DArray_compare cmp)$/;"	f	typeref:typename:void	file:
mergesort	darray_algos.c	/^static int mergesort(DArray* array, size_t size, DArray_compare cmp)$/;"	f	typeref:typename:int	file:
partition	darray_algos.c	/^static int partition(DArray* array, int low, int high, DArray_compare cmp)$/;"	f	typeref:typename:int	file:
quicksort	darray_algos.c	/^static void quicksort(DArray* array, int low, int high, DArray_compare cmp)$/;"	f	typeref:typename:void	file:
DARRAY_HEAPSORT	darray_algos.h	/^#define DARRAY_HEAPSORT /;"	d
DARRAY_MERGESORT	darray_algos.h	/^#define DARRAY_MERGESORT /;"	d
DARRAY_QUICKSORT	darray_algos.h	/^#define DARRAY_QUICKSORT /;"	d
DArray_compare	darray_algos.h	/^typedef int (*DArray_compare) (const void* a, const void* b);$/;"	t	typeref:typename:int (*)(const void * a,const void * b)
DArray_swap	darray_algos.h	/^static inline void DArray_swap(DArray* array, unsigned int i, unsigned int j)$/;"	f	typeref:typename:void
darray_algos_h	darray_algos.h	/^#define darray_algos_h$/;"	d
__dbg_h__	dbg.h	/^#define __dbg_h__ /;"	d
check	dbg.h	/^#define check(/;"	d
check_debug	dbg.h	/^#define check_debug(/;"	d
check_mem	dbg.h	/^#define check_mem(/;"	d
clean_errno	dbg.h	/^#define clean_errno(/;"	d
debug	dbg.h	/^#define debug(/;"	d
log_err	dbg.h	/^#define log_err(/;"	d
log_info	dbg.h	/^#define log_info(/;"	d
log_warn	dbg.h	/^#define log_warn(/;"	d
sentinel	dbg.h	/^#define sentinel(/;"	d
Hashmap_create	hashmap.c	/^Hashmap * Hashmap_create(Hashmap_compare compare, Hashmap_hash hash)$/;"	f	typeref:typename:Hashmap *
Hashmap_createDynamic	hashmap.c	/^Hashmap * Hashmap_createDynamic(Hashmap_compare compare, Hashmap_hash hash, size_t bucket_size, /;"	f	typeref:typename:Hashmap *
Hashmap_createStatic	hashmap.c	/^Hashmap * Hashmap_createStatic(Hashmap_compare compare, Hashmap_hash hash, size_t bucket_size)$/;"	f	typeref:typename:Hashmap *
Hashmap_delete	hashmap.c	/^void* Hashmap_delete(Hashmap* map, void* key)$/;"	f	typeref:typename:void *
Hashmap_destroy	hashmap.c	/^void Hashmap_destroy(Hashmap* map)$/;"	f	typeref:typename:void
Hashmap_find_bucket	hashmap.c	/^static inline DArray* Hashmap_find_bucket(Hashmap* map, void* key, int create, uint32_t* hash_ou/;"	f	typeref:typename:DArray *	file:
Hashmap_get	hashmap.c	/^void* Hashmap_get(Hashmap* map, void* key)$/;"	f	typeref:typename:void *
Hashmap_getSize	hashmap.c	/^size_t Hashmap_getSize(Hashmap * map)$/;"	f	typeref:typename:size_t
Hashmap_getThreshold	hashmap.c	/^static inline size_t Hashmap_getThreshold(Hashmap * map)$/;"	f	typeref:typename:size_t	file:
Hashmap_get_node	hashmap.c	/^static inline int Hashmap_get_node(Hashmap* map, uint32_t hash, DArray* bucket, void* key)$/;"	f	typeref:typename:int	file:
Hashmap_node_create	hashmap.c	/^static inline HashmapNode* Hashmap_node_create(int hash, void* key, void* data)$/;"	f	typeref:typename:HashmapNode *	file:
Hashmap_rehash	hashmap.c	/^static bool Hashmap_rehash(Hashmap * map, DArray * new_buckets)$/;"	f	typeref:typename:bool	file:
Hashmap_resize	hashmap.c	/^static bool Hashmap_resize(Hashmap * map)$/;"	f	typeref:typename:bool	file:
Hashmap_set	hashmap.c	/^int Hashmap_set(Hashmap* map, void* key, void* data)$/;"	f	typeref:typename:int
Hashmap_traverse	hashmap.c	/^int Hashmap_traverse(Hashmap* map, Hashmap_traverse_cb traverse_cb)$/;"	f	typeref:typename:int
default_compare	hashmap.c	/^static int default_compare(const void * a, const void * b)$/;"	f	typeref:typename:int	file:
default_hash	hashmap.c	/^static uint32_t default_hash(void * a ,uint32_t seed)$/;"	f	typeref:typename:uint32_t	file:
default_node_compare	hashmap.c	/^static int default_node_compare(const HashmapNode * a, const HashmapNode * b)$/;"	f	typeref:typename:int	file:
DEFAULT_NUMBER_OF_BUCKETS	hashmap.h	/^#define DEFAULT_NUMBER_OF_BUCKETS /;"	d
Hashmap	hashmap.h	/^typedef struct Hashmap{$/;"	s
Hashmap	hashmap.h	/^}Hashmap;$/;"	t	typeref:struct:Hashmap
HashmapNode	hashmap.h	/^typedef struct HashmapNode{$/;"	s
HashmapNode	hashmap.h	/^}HashmapNode;$/;"	t	typeref:struct:HashmapNode
Hashmap_compare	hashmap.h	/^typedef int (*Hashmap_compare) (const void* a, const void* b); \/\/ Pointer to Function for comp/;"	t	typeref:typename:int (*)(const void * a,const void * b)
Hashmap_hash	hashmap.h	/^typedef uint32_t (*Hashmap_hash) (void* key, uint32_t seed); \/\/ Pointer to a Function for gene/;"	t	typeref:typename:uint32_t (*)(void * key,uint32_t seed)
Hashmap_traverse_cb	hashmap.h	/^typedef int (*Hashmap_traverse_cb) (HashmapNode* node);$/;"	t	typeref:typename:int (*)(HashmapNode * node)
_lcthw_Hashmap_h	hashmap.h	/^#define _lcthw_Hashmap_h$/;"	d
bucket_size	hashmap.h	/^	size_t bucket_size; \/\/ or called capacity in someplaces$/;"	m	struct:Hashmap	typeref:typename:size_t
buckets	hashmap.h	/^	DArray * buckets; $/;"	m	struct:Hashmap	typeref:typename:DArray *
compare	hashmap.h	/^	Hashmap_compare compare; \/\/ Pointer to a function for comparing keys$/;"	m	struct:Hashmap	typeref:typename:Hashmap_compare
data	hashmap.h	/^	void * data;$/;"	m	struct:HashmapNode	typeref:typename:void *
entries	hashmap.h	/^	size_t entries; \/\/ current no. of elements in the map, updated at every add \/ delete functio/;"	m	struct:Hashmap	typeref:typename:size_t
hash	hashmap.h	/^	Hashmap_hash hash; \/\/ Pointer to a function for generating the hash$/;"	m	struct:Hashmap	typeref:typename:Hashmap_hash
hash	hashmap.h	/^	uint32_t hash;$/;"	m	struct:HashmapNode	typeref:typename:uint32_t
key	hashmap.h	/^	void * key;$/;"	m	struct:HashmapNode	typeref:typename:void *
load_factor	hashmap.h	/^	double load_factor; \/\/ helps us determine a threshold for resizing$/;"	m	struct:Hashmap	typeref:typename:double
seed	hashmap.h	/^	uint32_t seed; \/\/ This will be initialized once and then used for the lifetime of the program$/;"	m	struct:Hashmap	typeref:typename:uint32_t
FNV_OFFSET_BASIS	hashmap_algos.c	/^constexpr uint32_t FNV_OFFSET_BASIS = 2166136261;$/;"	v	typeref:typename:constexpr uint32_t
FNV_PRIME	hashmap_algos.c	/^constexpr uint32_t FNV_PRIME = 16777619;$/;"	v	typeref:typename:constexpr uint32_t
Hashmap_adler32_hash	hashmap_algos.c	/^uint32_t Hashmap_adler32_hash(void* data, uint32_t seed)$/;"	f	typeref:typename:uint32_t
Hashmap_adler32_hash_gen	hashmap_algos.c	/^uint32_t Hashmap_adler32_hash_gen(const void * key, size_t len, uint32_t seed)$/;"	f	typeref:typename:uint32_t
Hashmap_djb_hash	hashmap_algos.c	/^uint32_t Hashmap_djb_hash(void* data, uint32_t seed)$/;"	f	typeref:typename:uint32_t
Hashmap_djb_hash_gen	hashmap_algos.c	/^uint32_t Hashmap_djb_hash_gen(const void * key, size_t len, uint32_t seed)$/;"	f	typeref:typename:uint32_t
Hashmap_fnv1a_hash	hashmap_algos.c	/^uint32_t Hashmap_fnv1a_hash(void* data, uint32_t  seed)$/;"	f	typeref:typename:uint32_t
Hashmap_fnv1a_hash_gen	hashmap_algos.c	/^uint32_t Hashmap_fnv1a_hash_gen(const void * key, size_t len, uint32_t seed)$/;"	f	typeref:typename:uint32_t
Hashmap_murmur3_32_hash	hashmap_algos.c	/^uint32_t Hashmap_murmur3_32_hash(const void * key, size_t len, uint32_t seed)$/;"	f	typeref:typename:uint32_t
MOD_ADLER	hashmap_algos.c	/^constexpr int MOD_ADLER = 65521;$/;"	v	typeref:typename:constexpr int
ROTL32	hashmap_algos.c	/^static inline uint32_t ROTL32 ( uint32_t x, int8_t r )$/;"	f	typeref:typename:uint32_t	file:
fmix32	hashmap_algos.c	/^static inline uint32_t fmix32 ( uint32_t h )$/;"	f	typeref:typename:uint32_t	file:
getblock32	hashmap_algos.c	/^static inline uint32_t getblock32 ( const uint32_t * p, int i )$/;"	f	typeref:typename:uint32_t	file:
hashmap_algos_h	hashmap_algos.h	/^#define hashmap_algos_h$/;"	d
List_clear	list.c	/^void List_clear(List* list)$/;"	f	typeref:typename:void
List_clear_destroy	list.c	/^void List_clear_destroy(List* list)$/;"	f	typeref:typename:void
List_create	list.c	/^List* List_create()$/;"	f	typeref:typename:List *
List_destroy	list.c	/^void List_destroy(List* list)$/;"	f	typeref:typename:void
List_pop	list.c	/^void* List_pop(List* list)$/;"	f	typeref:typename:void *
List_push	list.c	/^void List_push(List* list, void* value)$/;"	f	typeref:typename:void
List_remove	list.c	/^void* List_remove(List* list, ListNode* node)$/;"	f	typeref:typename:void *
List_shift	list.c	/^void* List_shift(List* list)$/;"	f	typeref:typename:void *
List_unshift	list.c	/^void List_unshift(List* list, void* value)$/;"	f	typeref:typename:void
LIST_FOREACH	list.h	/^#define LIST_FOREACH(/;"	d
List	list.h	/^typedef struct List{$/;"	s
List	list.h	/^}List;$/;"	t	typeref:struct:List
ListNode	list.h	/^typedef struct ListNode{$/;"	s
ListNode	list.h	/^}ListNode;$/;"	t	typeref:struct:ListNode
List_count	list.h	/^#define List_count(/;"	d
List_first	list.h	/^#define List_first(/;"	d
List_last	list.h	/^#define List_last(/;"	d
count	list.h	/^	int count; \/\/ This variable keeps track of the no. of nodes$/;"	m	struct:List	typeref:typename:int
first	list.h	/^	ListNode* first;$/;"	m	struct:List	typeref:typename:ListNode *
last	list.h	/^	ListNode* last;$/;"	m	struct:List	typeref:typename:ListNode *
lcthw_list_h	list.h	/^#define lcthw_list_h$/;"	d
next	list.h	/^	struct ListNode* next; \/\/ pointer to the next node$/;"	m	struct:ListNode	typeref:struct:ListNode *
prev	list.h	/^	struct ListNode* prev; \/\/ pointer to the previous node$/;"	m	struct:ListNode	typeref:struct:ListNode *
value	list.h	/^	void* value; \/\/ This is the value that the node will hold, it is declared void for used for a/;"	m	struct:ListNode	typeref:typename:void *
ListNode_swap	list_algos.c	/^inline void ListNode_swap(ListNode* a, ListNode* b)$/;"	f	typeref:typename:void
List_bubble_sort	list_algos.c	/^int List_bubble_sort(List* list, List_compare cmp)$/;"	f	typeref:typename:int
List_merge	list_algos.c	/^static inline List* List_merge(List* left, List* right, List_compare cmp)$/;"	f	typeref:typename:List *	file:
List_merge_sort	list_algos.c	/^List* List_merge_sort(List* list, List_compare cmp)$/;"	f	typeref:typename:List *
List_compare	list_algos.h	/^typedef int (*List_compare) (const void* a, const void* b);$/;"	t	typeref:typename:int (*)(const void * a,const void * b)
lcthw_list_algos_h	list_algos.h	/^#define lcthw_list_algos_h$/;"	d
